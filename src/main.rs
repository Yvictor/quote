// use quote::paser::f6::bytes2f6;
use quote::io::fs::{readf6file, readf6filebuffer};
use quote::paser::f6::F6;
use quote::io::mcast::{join_mcast, process};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::path::Path;
use std::io::Write;
use chrono::Local;
use env_logger::Builder;
use log::LevelFilter;
// use log::info;

fn main() {
    Builder::new()
        .format(|buf, record| {
            writeln!(
                buf,
                "{} [{}] - {}",
                Local::now().format("%Y-%m-%dT%H:%M:%S.%f"),
                record.level(),
                record.args()
            )
        })
        .filter(None, LevelFilter::Info)
        .init();
    fn f6handler(f6: F6) {
        // println!("{:?}", f6);
    }
    let path = Path::new("tests/data/f6_01000001_01001000_TP03.new");
    // let path = Path::new("集中市場行情格式六_04000001_04500000_TP09.new");
    let display = path.display();
    log::info!("start parsing file: {}", display);
    // readf6file(&Path::new("集中市場行情格式六_01000001_01500000_TP03.new"), f6handler);
    readf6file(&path, f6handler);
    log::info!("readf6file");
    readf6filebuffer(&path, f6handler);
    log::info!("finish");
    
    // let mcast_addr: SocketAddr = SocketAddr::new(IpAddr::from(Ipv4Addr::new(224, 0, 100, 100)), 10000);
    // let if_addr: SocketAddr = SocketAddr::new(IpAddr::from(Ipv4Addr::new(192, 168, 32, 23)), 10000);
    // let socket = join_mcast(mcast_addr, if_addr).unwrap();
    // process(socket, f6handler);

    // let rows: [&[u8]; 2] = [
    //     &[
    //         0x1b, 0x0, 0x41, 0x1, 0x6, 0x4, 0x0, 0x0, 0x0, 0x11, 0x30, 0x30, 0x36, 0x33, 0x32,
    //         0x52, 0x8, 0x30, 0x0, 0x92, 0x9, 0x15, 0x10, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    //         0x6, 0x32, 0x0, 0x0, 0x0, 0x0, 0x1, 0x25,
    //     ],
    //     &[
    //         0x1b, 0x1, 0x31, 0x1, 0x6, 0x4, 0x0, 0x10, 0x93, 0x59, 0x39, 0x31, 0x31, 0x36, 0x31,
    //         0x36, 0x9, 0x0, 0x0, 0x14, 0x8, 0x66, 0xda, 0x0, 0x8, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0,
    //         0x1, 0x82, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x1, 0x82, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0,
    //         0x0, 0x1, 0x81, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x1, 0x80, 0x0, 0x0, 0x0, 0x0, 0x16,
    //         0x0, 0x0, 0x1, 0x76, 0x0, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x1, 0x75, 0x0, 0x0, 0x0, 0x0,
    //         0x20, 0x0, 0x0, 0x1, 0x93, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x1, 0x94, 0x0, 0x0, 0x0,
    //         0x0, 0x1, 0x0, 0x0, 0x1, 0x95, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x96, 0x0, 0x0,
    //         0x0, 0x0, 0x25, 0x0, 0x0, 0x1, 0x97, 0x0, 0x0, 0x0, 0x0, 0x26, 0xc6,
    //     ],
    // ];
    // for row in rows {
    //     let f6 = bytes2f6(row);
    //     let serialized = serde_json::to_string(&f6).unwrap();
    //     println!("serialized = {}", serialized);
    //     println!("{:?}", bytes2f6(row));
    // }
}
